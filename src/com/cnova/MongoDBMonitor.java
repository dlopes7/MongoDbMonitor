
 /**
  * This template file was generated by dynaTrace client.
  * The dynaTrace community portal can be found here: http://community.compuwareapm.com/
  * For information how to publish a plugin please visit http://community.compuwareapm.com/plugins/contribute/
  **/ 

package com.cnova;


import com.dynatrace.diagnostics.pdk.*;
import com.mongodb.DB;
import com.mongodb.MongoCredential;
import com.mongodb.CommandResult;
import com.mongodb.DBCollection;
import com.mongodb.MongoClient;
import com.mongodb.MongoClientOptions;
import com.mongodb.ServerAddress;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.OutputStreamWriter;
import java.net.UnknownHostException;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.json.JSONArray;
import org.json.JSONObject;


public class MongoDBMonitor implements Monitor {

	private static final Logger log = Logger.getLogger(MongoDBMonitor.class.getName());

	private static final String CONFIG_PORT = "port";
	private static final String CONFIG_USERNAME = "user";
	private static final String CONFIG_PASSWORD = "password";
	private static final String[] MEASURE_GROUPS = new String [] {
		"Connections",
		"Memoria",
		"Operations",
		"Replication Operations",
		"Database Status",
		"Network"
	};
	
	private Map<String, String> MSR_CONNECTIONS = new HashMap<String, String>();
	private Map<String, String> MSR_MEMORIA = new HashMap<String, String>();
	private Map<String, String> MSR_OPERATIONS = new HashMap<String, String>();
	private Map<String, String> MSR_OPERATIONS_REPL = new HashMap<String, String>();
	private Map<String, String> MSR_DATABASE_STATUS = new HashMap<String, String>();
	private Map<String, String> MSR_NETWORK = new HashMap<String, String>();
	
	private MongoClient mongoClient;
	private String user;
	private String pass;
	private String host;
	private int port;
	
	@Override
	public Status setup(MonitorEnvironment env) throws Exception {
		MSR_CONNECTIONS.put("Current Connections", "current");
		MSR_CONNECTIONS.put("Available Connections", "available");
		MSR_CONNECTIONS.put("Total Created", "totalCreated");
		
		MSR_MEMORIA.put("Resident", "resident");
		MSR_MEMORIA.put("Virtual", "virtual");
		MSR_MEMORIA.put("Mapped", "mapped");
		MSR_MEMORIA.put("Mapped With Journal", "mappedWithJournal");
		
		MSR_OPERATIONS.put("Insert", "insert");
		MSR_OPERATIONS.put("Query", "query");
		MSR_OPERATIONS.put("Update", "update");
		MSR_OPERATIONS.put("Delete", "delete");
		MSR_OPERATIONS.put("Get More", "getmore");
		MSR_OPERATIONS.put("Command", "command");
		
		MSR_OPERATIONS_REPL.put("Insert", "insert");
		MSR_OPERATIONS_REPL.put("Query", "query");
		MSR_OPERATIONS_REPL.put("Update", "update");
		MSR_OPERATIONS_REPL.put("Delete", "delete");
		MSR_OPERATIONS_REPL.put("Get More", "getmore");
		MSR_OPERATIONS_REPL.put("Command", "command");
		
		MSR_DATABASE_STATUS.put("Collections", "collections");
		MSR_DATABASE_STATUS.put("Objects", "objects");
		MSR_DATABASE_STATUS.put("Data Size", "dataSize");
		MSR_DATABASE_STATUS.put("Storage Size","storageSize");
		MSR_DATABASE_STATUS.put("Extents", "numExtents");
		MSR_DATABASE_STATUS.put("Indexes", "indexes");
		MSR_DATABASE_STATUS.put("Index Size", "indexSize");
		MSR_DATABASE_STATUS.put("File Size","fileSize");
		MSR_DATABASE_STATUS.put("Namespace Size MB", "nsSizeMB");
		
		MSR_NETWORK.put("Bytes In", "bytesIn");
		MSR_NETWORK.put("Bytes Out", "bytesOut");
		MSR_NETWORK.put("Requests", "numRequests");

		return new Status(Status.StatusCode.Success);
	}


	@Override
	public Status execute(MonitorEnvironment env) throws Exception {
		
		user = env.getConfigString(CONFIG_USERNAME);
		pass = env.getConfigPassword(CONFIG_PASSWORD);
		host = env.getHost().getAddress();
		port = Integer.parseInt(String.valueOf(env.getConfigLong(CONFIG_PORT)));
		
		log.warning("Connecting to mongo on " + env.getHost().getAddress() + "\n\n");
		Connection connectionAdmin = new Connection(host, port, user, pass, "admin");
		DB db = connectionAdmin.connectToAdminDB(); 

		
		//Actual execution of the commands happen here
		JSONObject resultadoServerStatus = new JSONObject(db.command("serverStatus"));
		JSONObject resultadoDBStats = new JSONObject(db.command("dbStats"));
		JSONObject replicaSetStats = new JSONObject(db.command("replSetGetStatus"));
		
		//STATUS DO REPLICA SET!
		Collection<MonitorMeasure> medidas = env.getMonitorMeasures("Replica Set Status", "State");
		for (MonitorMeasure medida : medidas) {
			medida.setValue(getReplicaSetState(host, replicaSetStats));
		}
		
		
		for (String group : MEASURE_GROUPS){
			log.warning(host + " - Processing metric group " + group);
			switch (group) {
			case "Connections":
				
				for (Map.Entry<String, String> entry : MSR_CONNECTIONS.entrySet()){
					Collection<MonitorMeasure> measures = env.getMonitorMeasures(group, entry.getKey());
					for (MonitorMeasure measure : measures) {
						measure.setValue(resultadoServerStatus.getJSONObject("connections").getInt(entry.getValue()));
						
					}
				    
				}
				break;
			case "Memoria":
				for (Map.Entry<String, String> entry : MSR_MEMORIA.entrySet()){
					Collection<MonitorMeasure> measures = env.getMonitorMeasures(group, entry.getKey());
					for (MonitorMeasure measure : measures) {
						measure.setValue(resultadoServerStatus.getJSONObject("mem").getInt(entry.getValue()));
					}
				}
				break;
			case "Operations":
				for (Map.Entry<String, String> entry : MSR_OPERATIONS.entrySet()){
					Collection<MonitorMeasure> measures = env.getMonitorMeasures(group, entry.getKey());
					for (MonitorMeasure measure : measures) {
						int valor = resultadoServerStatus.getJSONObject("opcounters").getInt(entry.getValue());
						long unsignedValor = valor & 0x00000000ffffffffL;
		
						measure.setValue(calculateDifference(entry.getKey(), Double.valueOf(unsignedValor), host));
					}
				}
				break;
			case "Replication Operations":
				for (Map.Entry<String, String> entry : MSR_OPERATIONS_REPL.entrySet()){
					Collection<MonitorMeasure> measures = env.getMonitorMeasures(group, entry.getKey());
					for (MonitorMeasure measure : measures) {
						int valor = resultadoServerStatus.getJSONObject("opcountersRepl").getInt(entry.getValue());
						long unsignedValor = valor & 0x00000000ffffffffL;
						
						measure.setValue(calculateDifference(entry.getKey(), Double.valueOf(unsignedValor), host+"_REPL"));
					}
				}
				break;
			case "Database Status":
				for (Map.Entry<String, String> entry : MSR_DATABASE_STATUS.entrySet()){

					Collection<MonitorMeasure> measures = env.getMonitorMeasures(group, entry.getKey());
					for (MonitorMeasure measure : measures) {
						long valor = resultadoDBStats.getInt(entry.getValue());
						measure.setValue(valor);
					}
				}
				break;
			case "Network":
				for (Map.Entry<String, String> entry : MSR_NETWORK.entrySet()){
					Collection<MonitorMeasure> measures = env.getMonitorMeasures(group, entry.getKey());
					for (MonitorMeasure measure : measures) {
						Double valor = resultadoServerStatus.getJSONObject("network").getDouble(entry.getValue());
						if (entry.getValue() == "bytesIn" || entry.getValue() == "bytesOut"){
							valor = valor / 60.0;		
						}
						measure.setValue(calculateDifference(entry.getKey(), valor, host));
					}
				}
				break;

			default:
				break;
			}	
		}
		
		/*
		Collection<MonitorMeasure> monitorMeasures = env.getMonitorMeasures("mymetricgroup", "mymetric");
		for (MonitorMeasure subscribedMonitorMeasure : monitorMeasures) {

			//this will book to the monitor measure
			subscribedMonitorMeasure.setValue(42);

			//for this subscribed measure we want to create a dynamic measure
			MonitorMeasure dynamicMeasure = env.createDynamicMeasure(subscribedMonitorMeasure, "Queue Name", "Queue 1");
			dynamicMeasure.setValue(24);

			//now we create another one for a different queue name
			dynamicMeasure = env.createDynamicMeasure(subscribedMonitorMeasure, "Queue Name", "Queue 2");
			dynamicMeasure.setValue(32);


		}
		*/
		

		

		
		//com.cnova.mongodb.monitor.connection
		
		connectionAdmin.closeConnection();
		return new Status(Status.StatusCode.Success);
	}

		@Override
	public void teardown(MonitorEnvironment env) throws Exception {
		 if (mongoClient != null) {
             mongoClient.close();
         }
	}
	 
    public DB connectToAdminDB(MongoCredential adminCredentials, MongoClientOptions options) {
        try {
        	if(options != null) {
        		mongoClient = new MongoClient(new ServerAddress(host, port), options);
        	} else {
        		mongoClient = new MongoClient(host, port);
        	}
        	
        } catch (UnknownHostException e) {
        	
            String msg = String.format("Unable to connect to mongodb; host=%s, port=%s",host , port);
            log.severe(msg);
            throw new RuntimeException(msg, e);
        }

        DB db = mongoClient.getDB(adminCredentials.getSource());
        
        boolean authenticated = db.authenticate(adminCredentials.getUserName(), adminCredentials.getPassword());
        if(!authenticated) {
        	String msg = String.format("Unable to authenticate with the db %s, user=%s, using password ****",
                    adminCredentials.getSource(), adminCredentials.getUserName());
        	log.severe(msg);
            throw new RuntimeException(msg);
        }
        return db;
    }
    public double calculateDifference(String metric, double current, String identifier) throws Exception{
    	File yourFile = new File(metric +"_"+ identifier + ".txt");
    	double actual = 0;
    	double previous = 0;
    	long unsignedPrevious;
    	boolean isUnsigned = false;
    	DecimalFormat format = new DecimalFormat();
    	format.setDecimalSeparatorAlwaysShown(false);
    	
    	
		try{
			if(!yourFile.exists()) {
			    yourFile.createNewFile();
			} 
			BufferedReader leitura = new BufferedReader(new FileReader(yourFile));
			
			String valorArquivo = leitura.readLine();


			
			if(valorArquivo != null){
				if (valorArquivo.charAt(0) == '-'){
					isUnsigned = true;
				}
				try {
					if (isUnsigned){
						unsignedPrevious = Integer.parseInt(valorArquivo) & 0x00000000ffffffffL;
						previous = unsignedPrevious;
						
					}
					else{
						previous = Double.valueOf(valorArquivo);
					}
	
					
				} catch (Exception e) {
				
					previous = current;
					log.severe(host + " ERRO no calculo de diferenca! " + metric + " " + identifier);
					log.log(Level.SEVERE, e.getMessage(), e);
					e.printStackTrace();
					leitura.close();
					throw e;
				}
			}else{
				previous = current;
				
			}
			
			if (current >= previous){
				actual = current - previous;
			}else{
				//Algo errado aqui, o valor atual é menor que o anterior, descarto o ponto
				actual = 0;
			}


			leitura.close();
			
			FileOutputStream oFile = new FileOutputStream(yourFile, false); 
			BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(oFile));
			
			String valorASerEscrito = format.format(current).replace(",", "");
			bw.write(valorASerEscrito);
			bw.close();
			
		}catch (Exception e){
			e.printStackTrace();
			log.severe("\nPREVIOUS: " + previous +" \nCURRENT: " +current+ "\nACTUAL: " + actual );
			log.severe(host);
			log.log(Level.SEVERE, e.getMessage(), e);
			throw e;
			
		}
		return actual;
    }
    
    public int getReplicaSetState(String host, JSONObject replicaSetJson){
    	String nome;
    	int status = -1;
    	
    	JSONArray membrosReplicaSet = replicaSetJson.getJSONArray("members");
    	
    	for (int i = 0; i < membrosReplicaSet.length(); i++){
    		
			nome = membrosReplicaSet.getJSONObject(i).getString("name");
			
			if (nome.toLowerCase().contains(host.toLowerCase())){
				status =  membrosReplicaSet.getJSONObject(i).getInt("state");
				log.warning("Host: " + nome + ": " + status);
				return status;
				
			}
			
		}
    	if (status != -1){
    		return status;
    	}else{
    		// 6 = Status UNKNOWN
    		return 6;
    	}
    	
    }
    
}
